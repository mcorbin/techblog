<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>(mcorbin.fr): A propos de Clojure</title>
    <link rel="canonical" href="https://mcorbin.fr/posts/2017-04-05-a-propos-clojure/">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
    <link href="/css/font-awesome.min.css" rel="stylesheet" type="text/css" />
    <link href="/css/styles/tomorrow-night.css" rel="stylesheet" type="text/css" />
    <link href="/css/screen.css" rel="stylesheet" type="text/css" />

  </head>
  <body><a name="top"></a>
    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar1" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">(mcorbin.fr)</a>
        </div>
        <div id="navbar1" class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
            <li ><a href="/">Home</a></li>
            <li
               ><a href="/archives/">Archives</a></li>
            
            <li
               >
              <a href="/pages/about/">About</a>
            </li>
            
            <li
               >
              <a href="/pages/projects/">Projects</a>
            </li>
            
            <li><a href="/feed.xml">RSS</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div><!--/.container-fluid -->
    </nav>


    <div class="container">
      <div class="row">
        <div class="col-lg-12">
          <div id="content">
            
<div id="post">
    <div class="post-header">
    <div id="post-meta" class="row">
        <div class="col-lg-6">5 avril 2017</div>
        
    </div>
    <h2>A propos de Clojure</h2>
</div>
<div>
    
    <div class="paragraph">
<p>Ça fait maintenant plus de 2 ans que je me suis mis à <a href="http://clojure.org/">Clojure</a>.
Bien m&#8217;en a pris.
C&#8217;est aujourd&#8217;hui le langage où je suis le plus à l&#8217;aise.</p>
</div>
<div class="paragraph">
<p>Je tâcherais dans cet article d&#8217;expliquer pourquoi Clojure est un langage à la fois simple, puissant, et extrêmement fun.</p>
</div>
<div class="sect1">
<h2 id="_histoire">Histoire</h2>
<div class="sectionbody">
<div class="paragraph">
<p>La version 1.0 de Clojure est sortie en 2009.
Le langage fonctionne sur la JVM (sa cible initiale) mais compile également en Javascript (via le projet ClojureScript).
Un port de Clojure sur CLR existe également, mais moins populaire que les version Java/JS.</p>
</div>
<div class="paragraph">
<p>La force de Clojure est qu&#8217;il s&#8217;interface parfaitement avec sa plateforme cible, c&#8217;est à dire qu&#8217;il est très facile d&#8217;utiliser l&#8217;énorme écosystème (libraries, frameworks, outils&#8230;&#8203;) de ces plateformes depuis Clojure.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_syntaxe">Syntaxe</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clojure est inspiré de LISP.
Pour un développeur habitué à C, Java, Python&#8230;&#8203; cela peut faire peur.
Pourtant la syntaxe de Clojure (et de LISP en général) est une de ses plus grandes forces.</p>
</div>
<div class="paragraph">
<p>Voici une explication simple de la syntaxe de Clojure :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1 + 1

foo(bar)

foo(bar, baz)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(+ 1 1)

(foo bar)

(foo bar baz)</code></pre>
</div>
</div>
<div style="clear:both;"></div>
<div class="paragraph">
<p>On se rend compte facilement qu&#8217;en Clojure, l&#8217;opérateur (ou la fonction, le mot clé&#8230;&#8203;) se trouve en premier (après une parenthèse) suivi de ses arguments.</p>
</div>
<div class="paragraph">
<p>Allons un peu plus loin :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public int addFive(int number) {
    return number + 5;
}

public int addFiveIfOdd(int number) {
    if (number % 2 == 0) {
        return number + 5;
    }
    return number;
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(defn add-five
  [number]
  (+ number 5))

(defn add-five-if-odd
  [number]
  (if (odd? number)
    (+ 5 number)
    number))</code></pre>
</div>
</div>
<div class="paragraph">
<p>On voit ici que la syntaxe de Clojure respecte toujours le même format.
Une ouverture de parenthèse, un mot clé, et une suite d&#8217;arguments.
Quelle que soit l&#8217;action à réaliser (un if, une définition de fonction, un appel de fonction&#8230;&#8203;), la syntaxe reste la même.</p>
</div>
<div class="paragraph">
<p>Je trouve personnellement cela très intéressant, et une fois l&#8217;habitude prise, lire du Clojure est très agréable (je vous promets que les parenthèses, vous ne les verrez plus ;)).</p>
</div>
<div class="paragraph">
<p>D&#8217;ailleurs, en parlant de parenthèses, comparez les deux codes suivants :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Integer&gt; mylist =
    Arrays.asList(1, 2, 3, 4);
myList.stream()
   .map( x -&gt; x + 1)
   .mapToInt(x -&gt; x)
   .sum();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">(reduce + (map inc [1 2 3 4]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Comptez le nombre de symboles différents dans le code Java.
On a <code>(){}&lt;&gt;,&#8594;;.</code>, et beaucoup plus de parenthèses que dans la version Clojure.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_immutabilité">Immutabilité</h2>
<div class="sectionbody">
<div class="paragraph">
<p>En Clojure, (presque) tout est immutable.
Cela se voit dès que l&#8217;on touche au langage :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">riemann.bin&gt; (def foo [1 2])
#'riemann.bin/foo
riemann.bin&gt; (conj foo 3)
[1 2 3]
riemann.bin&gt; (conj foo 4)
[1 2 4]
riemann.bin&gt; foo
[1 2]
riemann.bin&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>La même chose s&#8217;applique lors de passage de paramètre à des fonctions :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">riemann.bin&gt; (defn my-fn [my-vec] (conj my-vec 10))
#'riemann.bin/my-fn
riemann.bin&gt; (my-fn foo)
[1 2 10]
riemann.bin&gt; (my-fn foo)
[1 2 10]
riemann.bin&gt; (my-fn [1 2 3])
[1 2 3 10]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Il n&#8217;y a plus à s&#8217;inquiéter des effets de bords, toutes les structures de données de Clojure sont immutables.
Attention par contre si vous utilisez des objets Java (en utilisant l&#8217;intéropérabilité Clojure/Java), le code perdra cette propriété.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_repl_développement_intéractif">REPL, développement intéractif</h2>
<div class="sectionbody">
<div class="paragraph">
<p>J&#8217;adore Clojure car la façon de coder en Clojure correspond bien à ma façon de réfléchir.
Lorsque je code en Clojure, j&#8217;ai toujours le REPL (l&#8217;interpréteur Clojure) ouvert. Je peux comme cela coder dans mon fichier .clj, le charger dans le REPL et le "tester" en live.</p>
</div>
<div class="paragraph">
<p>Cela est très intéressant et permet d&#8217;avoir très rapidement un retour sur ce qu&#8217;on écrit.
C&#8217;est vraiment la technique ultime pour expérimenter, tester rapidement plusieurs solutions à un problème.
C&#8217;est aussi très bien pour apprendre le langage.</p>
</div>
<div class="paragraph">
<p>Pour résumer, mon workflow quand je code en Clojure c&#8217;est :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Explorer les solutions à un problème avec le REPL. En faisant cela, je comprends mieux mon problème, les différentes solutions qui s&#8217;offrent à moi, comment je peux découper le code&#8230;&#8203;</p>
</li>
<li>
<p>Ecrire des tests</p>
</li>
<li>
<p>Refactorer ma solution (qui est souvent bancale et ne passe pas mes tests).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Les aficionados du TDD ne seraient pas forcément d&#8217;accord avec moi, mais je trouve que manipuler un peu le problème avant d&#8217;écrire des tests apporte une énorme plus value.</p>
</div>
<div class="paragraph">
<p>Le REPL est également agréable à utiliser grâce à la syntaxe simple et expressive de Clojure. Parait que Java 9 aura également un REPL, cool, mais je me vois mal taper dans un REPL à longueur de journée :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ArrayList&lt;String&gt; foolist = new ArrayList&lt;String&gt;();
list.add("foo");
list.add("bar");
list.add("baz");
Map&lt;Integer, &lt;List&lt;String&gt;&gt; foomap = new HashMap&lt;&gt;();
foomap.put(20, foolist)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Et vous ? Pour information, l&#8217;équivalent Clojure est <code><code>{20 ["foo" "bar" "baz"]}</code></code></p>
</div>
<div class="paragraph">
<p>Le fait que les fonctions prennent et retournent généralement des structures de données immutables aide aussi.
Pour tout ce qui est état (connexions aux base de données, web servers&#8230;&#8203;)
des outils comme <a href="https://github.com/tolitius/mount">mount</a> permettent de définir et recharger en une commande l&#8217;intégralité du programme.</p>
</div>
<div class="paragraph">
<p>Le REPL est probablement ce qui me manque le plus dans d&#8217;autres langages.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_programmation_concurrente">Programmation concurrente</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clojure fournit plusieurs outils permettant de partager facilement des ressources entre threads.</p>
</div>
<div class="paragraph">
<p>Un <a href="https://clojure.org/reference/atoms">atom</a> permet de définir une variable où chaque opération sera atomique. Exemple :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>riemann.bin&gt; (def foo (atom [1 2]))
#'riemann.bin/foo
riemann.bin&gt; foo
#atom[[1 2] 0x58749e6e]
riemann.bin&gt; @foo
[1 2]
riemann.bin&gt; (swap! foo conj 3)
[1 2 3]
riemann.bin&gt; @foo
[1 2 3]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ici, je définis un atom foo. <code>@foo</code> permet de déférencer l&#8217;atom, c&#8217;est à dire récupérer sa valeur. <code>swap!</code> permet d&#8217;appliquer une opération sur un atom (ici en y ajoutant la valeur 3).</p>
</div>
<div class="paragraph">
<p>Les atom ont donc un état (et ne sont pas immutables). L&#8217;intêret des atom est qu&#8217;ils sont thread safe.</p>
</div>
<div class="paragraph">
<p>Imaginons que 2 threads appellent <code>swap!</code> simultanément sur un atom, par exemple <code>(swap! foo conj 3)</code> sur le thread 1 puis <code>(swap! foo conj 4)</code> sur le thread 2.
Si l&#8217;atom valait initialement <code>[1 2]</code>, les "bonnes" réponses possibles sont <code>[1 2 3 4]</code>
 ou <code>[1 2 4 3]</code> une fois l&#8217;opération exécutée.</p>
</div>
<div class="paragraph">
<p>Imaginons que l&#8217;opération 1 se termine. L&#8217;atom vaudra donc <code>[1 2 3]</code>.
Pas de chance, pendant ce temps là sur le thread 2, l&#8217;opération swap! produit <code>[1 2 4]</code> (les deux opérations ayant été lancés au même moment, l&#8217;état de l&#8217;atom en entrée était le même pour les deux).</p>
</div>
<div class="paragraph">
<p>Nous ne voulons surtout pas que le résultat final soit <code>[1 2 4]</code>.
Heureusement, <code>swap!</code> détectera que l&#8217;atom a changé pendant qu&#8217;il réalisait l&#8217;opération, et va donc re-réaliser l&#8217;opération en prenant le nouveau état comme paramètre d&#8217;entrée.
On obtiendra donc comme résultat final <code>[1 2 3 4]</code>. Le tout sans lock :)</p>
</div>
<div class="paragraph">
<p>Un peu de la même façon, les <a href="https://clojure.org/reference/refs">refs</a> permettent de définir des opérations entre plusieurs variables mutables partagées entre plusieurs threads de manière safe, grâce à un système de transaction.</p>
</div>
<div class="paragraph">
<p>Les atom et les ref viennent en plus avec des fonctionnalités intéressantes, comme le fait de pouvoir définir des fonctions qui seront appelées (avec en paramètre l&#8217;ancien et le nouveau état de l&#8217;atom ou de la ref) une fois une action réalisée.
Des fonctions de validations peuvent également être liées aux refs ou atom pour refuser certains états.</p>
</div>
<div class="paragraph">
<p>Clojure implémente également d&#8217;autres mécanismes pour la gestion de la concurrence (comme les <a href="https://clojure.org/reference/agents">agents</a>, ou bien <a href="https://github.com/clojure/core.async">core.async</a> qui permet de créer plusieurs processes qui communiqueront avec des channels (un peu à la Go)).
Et évidemment, tout ce qui tourne sur la JVM (donc java.util.concurrent par exemple) est également disponible.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_macros">Macros</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Une liste se définit de cette façon en Clojure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">riemann.bin&gt; '(1 2 3)
(1 2 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Définissons une nouvelle liste (rappel: de part sa nature dynamique, une liste en Clojure peut contenir tout et n&#8217;importe quoi) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">riemann.bin&gt; '(defn my-fn [my-vec] (conj my-vec 10))
(defn my-fn [my-vec] (conj my-vec 10))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ma liste contient ici la définition de la fonction <code>my-fn</code> !
En clojure (et en LISP de façon plus générale), le code est une structure de données manipulable via un mécanisme appelé macros.
Par exemple, <code>defn</code> lui même est une macro:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-clojure" data-lang="clojure">riemann.bin&gt; (macroexpand '(defn my-fn2 [my-vec] (conj my-vec 10)))
(def my-fn2 (clojure.core/fn ([my-vec] (conj my-vec 10))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>macroexpand</code> retourne la forme "réelle" d&#8217;une expression Clojure.
On voit ici que defn est en fait un assemblage des mots-clés <code>def</code> et <code>fn</code>.</p>
</div>
<div class="paragraph">
<p>Les macros sont un outil très puissant (mais à utiliser avec modération), permettant de définir par exemple des DSL.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion">Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Clojure n&#8217;est pas parfait.
Il reste beaucoup à faire, comme par exemple les messages d&#8217;erreurs (qui sont des stacktrace Java peu expressives) qui ont tendances à faire fuir les nouveaux venus dans le langage.
La façon de travailler avec le REPL n&#8217;est pas également facile à acquérir seul.</p>
</div>
<div class="paragraph">
<p>Mais le langage est solide, cohérent, et a complètement changé ma façon de programmer (en bien).
La philosophie du langage (immutabilité, manipulation facile de structures de données, REPL, fonctions/librairies versus frameworks&#8230;&#8203;) correspond parfaitement à ma façon de développer.</p>
</div>
<div class="paragraph">
<p>Si vous ne l&#8217;avez pas encore fait, vous DEVEZ jeter un oeil à Clojure.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ressources">Ressources</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://aphyr.com/tags/Clojure-from-the-ground-up">Clojure from the group up</a> de Aphyr : une série de tutoriel sur le langage</p>
</li>
<li>
<p><a href="http://www.braveclojure.com/clojure-for-the-brave-and-true/">Brave Clojure</a> : Un tutoriel complet existant également au format livre.</p>
</li>
</ul>
</div>
</div>
</div>
</div>

<div id="post-tags">
    <b>Tags: </b>
    
    <a href="/tags/clojure/">clojure</a>
    
    <a href="/tags/programming/">programming</a>
    
</div>


    <div id="prev-next">
        
        <a href="/posts/2017-04-09-a-tour-of-riemann/">&laquo; A tour of Riemann</a>
        
        
        <a class="right" href="/posts/2016-08-10-logs-ansible/">Use your Ansible logs ! / Exploitez vos logs Ansible ! &raquo;</a>
        
    </div>

    


</div>

            <a href="#top" class="alink" >Top of page</a>
          </div>
        </div>
      </div>
      <footer>Copyright &copy; 2020 mcorbin</footer>
    </div>
    <script src="/js/jquery-1.11.0.min.js" type="text/javascript"></script>
    <script src="/js/bootstrap.min.js" type="text/javascript"></script>
    <script src="/js/highlight.pack.js" type="text/javascript"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>
